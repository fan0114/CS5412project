package cs5412.project.distributed_file_system.dao.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Types;
import java.util.Date;

import javax.inject.Inject;
import javax.inject.Named;
import javax.sql.DataSource;

import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.PreparedStatementCreator;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;

import cs5412.project.distributed_file_system.dao.FileDAO;
import cs5412.project.distributed_file_system.dao.UserDAO;
import cs5412.project.distributed_file_system.pojo.File;
import cs5412.project.distributed_file_system.pojo.User;

@Named
public class UserJdbcDAO implements UserDAO {

	@Inject
	private FileDAO fileDao;

	@Inject
	private JdbcTemplate jdbcTemplate;

	public void setDataSource(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate(dataSource);
	}

	// private static final class UserMapper implements RowMapper<User> {
	// public User mapRow(ResultSet rs, int rowNum) throws SQLException {
	// User user = new User();
	// user.setUid(rs.getInt("uid"));
	// user.setUsername(rs.getString("uname"));
	// user.setHashedPassword(rs.getString("password"));
	// user.setEmail(rs.getString("email"));
	// user.setRootfid(rs.getInt("rootfid"));
	// return user;
	// }
	// }

	@Override
	public User getUserByUid(int uid) {
		User ret = (User) this.jdbcTemplate
				.queryForObject(
						"select uid, uname, password, email, rootfid from User where uid = ?",
						new Object[] { uid }, new FileJdbcDAO.UserMapper());
		return ret;
	}

	// public boolean createHistory(int uid, int fidold, int fidnew, int type) {
	// try {
	// // create
	// if (type == 1) {
	// this.jdbcTemplate
	// .update("insert into History (timestamp, uid, File_fid_new, type) values (?, ?, ?, ?)",
	// new Object[] { new Date(), uid, fidnew, type });
	// // remove
	// } else if (type == 2) {
	// this.jdbcTemplate
	// .update("insert into History (timestamp, uid, File_fid_old, type) values (?, ?, ?, ?)",
	// new Object[] { new Date(), uid, fidold, type });
	// // update
	// } else if (type == 3) {
	// this.jdbcTemplate
	// .update("insert into History (timestamp, uid, File_fid_old, File_fid_new, type) values (?, ?, ?, ?, ?)",
	// new Object[] { new Date(), uid, fidold, fidnew,
	// type });
	// //
	// } else if (type == 4) {
	// this.jdbcTemplate
	// .update("insert into History (timestamp, uid, type) values (?, ?, ?)",
	// new Object[] { new Date(), uid, type });
	// }
	// } catch (DataAccessException e) {
	// return false;
	// }
	// return true;
	// }

	// public int createFileOnly(File file) {
	// final String INSERT_SQL =
	// "insert into File (fname, location, directory, hash, hiscount, uid, isdir, ishidden) values (?, ?, ?, ?, ?, ?, ?, ?)";
	// long autoGeneratedKey = -1;
	// final File _file = file;
	// KeyHolder keyHolder = new GeneratedKeyHolder();
	// try {
	// this.jdbcTemplate.update(new PreparedStatementCreator() {
	// public PreparedStatement createPreparedStatement(
	// Connection connection) throws SQLException {
	// PreparedStatement ps = connection.prepareStatement(
	// INSERT_SQL, new String[] { "fid" });
	// ps.setString(1, _file.getName());
	// ps.setString(2, _file.getLocation());
	// if (_file.getParentDir() <= 0) {
	// ps.setNull(3, Types.NULL);
	// } else {
	// ps.setInt(3, _file.getParentDir());
	// }
	// ps.setString(4, _file.getHash());
	// ps.setInt(5, _file.getReferenceCount());
	// ps.setInt(6, _file.getUid());
	// ps.setBoolean(7, _file.isDir());
	// ps.setBoolean(8, false);
	// return ps;
	// }
	// }, keyHolder);
	// autoGeneratedKey = (Long) keyHolder.getKey();
	//
	// } catch (Exception ex) {
	// return -1;
	// }
	// return (int) autoGeneratedKey;
	// }

	@Override
	public int createUser(User user) {
		int uid = createUserOnly(user);
		File file = new File();
		file.setDir(true);
		file.setName("root");
		file.setParentDir(0);
		//file.setReferenceCount(0);
		file.setUid(uid);
		int fid = fileDao.createFileOnly(file);
		fileDao.createHistory(uid, 0, fid, 1);
		user.setRootfid(fid);
		user.setUid(uid);
		boolean updateSuccess = updateUser(user);
		if (!updateSuccess) {
			return -1;
		}
		File master = new File();
		master.setDir(true);
		master.setName("master");
		master.setParentDir(fid);
		//master.setReferenceCount(0);
		master.setUid(uid);
		master.setBranch(true);
		int masterfid = fileDao.createFile(master);
		if (masterfid <= 0) {
			return -1;
		}
		return uid;
	}

	public int createUserOnly(User user) {
		final String INSERT_SQL = "insert into User (uname, password, email) values (?, ?, ?)";
		long autoGeneratedKey = -1;
		final User _user = user;
		KeyHolder keyHolder = new GeneratedKeyHolder();
		try {
			this.jdbcTemplate.update(new PreparedStatementCreator() {
				public PreparedStatement createPreparedStatement(
						Connection connection) throws SQLException {
					PreparedStatement ps = connection.prepareStatement(
							INSERT_SQL, new String[] { "uid" });
					ps.setString(1, _user.getUsername());
					ps.setString(2, _user.getHashedPassword());
					ps.setString(3, _user.getEmail());
					return ps;
				}
			}, keyHolder);
			autoGeneratedKey = (Long) keyHolder.getKey();
		} catch (Exception ex) {
			return -1;
		}
		return (int) autoGeneratedKey;
	}

	@Override
	public boolean updateUser(User user) {
		try {
			// System.out.println("update user uid = " + user.getUid()
			// + " rootfid = " + user.getRootfid());
			this.jdbcTemplate
					.update("update User set uname = ?, password=?, email=?, rootfid=? where uid = ?",
							new Object[] { user.getUsername(),
									user.getHashedPassword(), user.getEmail(),
									user.getRootfid(), user.getUid() });
		} catch (DataAccessException e) {
			return false;
		}
		return true;
	}

	@Override
	public boolean deleteUser(User user) {
		if (user.getUid() <= 0) {
			return false;
		}
		try {
			// TODO:
			// delete all files
			// delete all histories
			// delete user
			this.jdbcTemplate.update("delete from User where uid = ?",
					new Object[] { user.getUid() });

		} catch (DataAccessException e) {
			return false;
		}
		return true;
	}

	@Override
	public boolean userLogin(String username, String hashPassword) {
		User u = (User) this.jdbcTemplate
				.queryForObject(
						"select min(uid) as uid, uname, password, email, rootfid from User where uname = ?",
						new Object[] { username }, new FileJdbcDAO.UserMapper());
		if (u.getHashedPassword().equals(hashPassword)) {
			return true;
		} else {
			return false;
		}
	}

}
